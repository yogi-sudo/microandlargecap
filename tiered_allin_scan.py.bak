#!/usr/bin/env python3
import os, sys, datetime as dt, numpy as np, pandas as pd
from typing import Dict, List, Optional, Tuple, Union
from tqdm import tqdm
from eodhd_allin import eod, technicals, fundamentals, splits, dividends, earnings_calendar

# ---------- config ----------
YEARS = int(os.getenv("YEARS", 3))
TOPN  = int(os.getenv("TOPN", 10))
UNIVERSE_CAP = int(os.getenv("UNIVERSE_CAP", 0))  # 0 = all in file
OUTDIR = "out"
os.makedirs(OUTDIR, exist_ok=True)

# required input produced earlier by your tiering step
U_LARGE = os.getenv("U_LARGE", "out/universe_large.csv")
U_MID   = os.getenv("U_MID",   "out/universe_mid.csv")
U_MICRO = os.getenv("U_MICRO", "out/universe_micro.csv")

# ---------- helpers ----------
def read_universe(path: str) -> pd.DataFrame:
    if not os.path.exists(path):
        raise FileNotFoundError(f"Missing {path} — run your tier builder first.")
    df = pd.read_csv(path)
    # Expect columns: Ticker,Company,Price,MktCapB
    colmap = {c.lower(): c for c in df.columns}
    def pick(*alts):
        for a in alts:
            if a.lower() in colmap: return colmap[a.lower()]
        raise KeyError(f"{path}: missing column (tried {alts})")
    tcol = pick("Ticker")
    ncol = pick("Company","Name")
    mcol = pick("MktCapB","Approx. Market Cap ($B)")
    out = df[[tcol,ncol,mcol]].rename(columns={tcol:"Ticker", ncol:"Company", mcol:"MktCapB"})
    out["Ticker"] = out["Ticker"].astype(str).str.upper()
    if UNIVERSE_CAP > 0:
        out = out.head(UNIVERSE_CAP)
    return out

def daterange_start(years: int) -> str:
    return (dt.date.today() - dt.timedelta(days=365*years)).isoformat()

def feature_block(sym: str, start: str) -> pd.DataFrame:
    # OHLCV (adjusted)
    px = eod(f"{sym}", start=start)
    if px.empty: return pd.DataFrame()
    px["px"] = px["adjusted_close"].fillna(px["close"])
    px = px.sort_values("date").reset_index(drop=True)

    # Technicals — RSI14 and SMA20/SMA50 via prices (fast local calc)
    px["ret1"] = px["px"].pct_change()
    px["sma20"] = px["px"].rolling(20).mean()
    px["sma50"] = px["px"].rolling(50).mean()
    gain = px["px"].diff().clip(lower=0).rolling(14).mean()
    loss = (-px["px"].diff().clip(upper=0)).rolling(14).mean()
    rs = gain / (loss.replace(0, np.nan))
    px["rsi14"] = 100 - 100/(1 + rs)
    px["vol20"] = px["ret1"].rolling(20).std()
    px["vma20"] = px["volume"].rolling(20).mean()
    px["v_ratio"] = px["volume"] / (px["vma20"] + 1e-9)

    # Corporate actions (splits & dividends → yield last year)
    div = dividends(sym)
    if not div.empty:
        div_y1 = div[div["date"] >= (pd.Timestamp.today() - pd.Timedelta(days=365))]["dividend"].astype(float).sum()
        px["div_yield_ann"] = (div_y1 / px["px"]).fillna(0.0)
    else:
        px["div_yield_ann"] = 0.0

    # Simple “distance to 52w high”, short-term momentum
    px["hh_252"] = px["px"].rolling(252).max()
    px["dist_to_hh"] = (px["px"] / px["hh_252"] - 1.0)*100.0
    px["ret5"] = px["px"].pct_change(5)*100.0
    px["trend_up"] = ((px["sma20"] > px["sma50"]).astype(int))

    # Fundamentals (P/E, MarketCap, Beta if available)
    f = fundamentals(sym)
    pe = None
    cap = None
    beta = None
    try:
        pe = float(f.get("Highlights",{}).get("PERatio", np.nan))
        cap = float(f.get("Highlights",{}).get("MarketCapitalization", np.nan))
        beta = float(f.get("Technicals",{}).get("Beta", np.nan))
    except Exception:
        pass
    px["pe"] = pe
    px["mktcap"] = cap
    px["beta"] = beta

    # flag near earnings (next 10 days) – optional if calendar available
    try:
        cal = earnings_calendar([sym], dt.date.today().isoformat(), (dt.date.today()+dt.timedelta(days=10)).isoformat())
        near_e = 1 if not cal.empty else 0
    except Exception:
        near_e = 0
    px["near_earnings_10d"] = near_e

    return px

def rank_today(block: pd.DataFrame) -> Optional[pd.Series]:
    if block.empty: return None
    last = block.iloc[-1].copy()
    # A blended “quality+momentum+participation” score (tweak freely)
    parts = []
    # momentum/structure
    parts.append(np.tanh((last.get("ret5",0.0))/6.0 + 0.0))
    parts.append( 1.0 if last.get("trend_up",0)==1 else -0.5 )
    parts.append(np.tanh((0 - max(-20.0, min(0.0, last.get("dist_to_hh",0.0))))/10.0))  # closer to HH better
    # volume participation
    vr = float(last.get("v_ratio", 1.0))
    parts.append(np.tanh((vr - 1.0)))
    # dividend sweetener (tiny)
    parts.append(np.tanh(float(last.get("div_yield_ann",0.0))*2.0))
    # fundamentals nudge: penalize very high PE if present
    pe = last.get("pe", np.nan)
    if pd.notna(pe):
        parts.append(-np.tanh((max(0.0, pe-30.0))/30.0))
    score = float(np.sum(parts))
    last["Score"] = score
    return last

def scan_tier(name: str, df_universe: pd.DataFrame) -> pd.DataFrame:
    rows = []
    start = daterange_start(YEARS)
    tickers = df_universe["Ticker"].tolist()
    for t in tqdm(tickers, desc=f"{name.title()} tier", unit="stk"):
        sym = t if t.endswith(".AX") else f"{t}.AX"
        try:
            block = feature_block(sym, start)
            r = rank_today(block)
            if r is not None:
                rows.append(r)
        except Exception:
            continue
    if not rows:
        return pd.DataFrame()
    out = pd.DataFrame(rows)
    out["Tier"] = name
    # friendly columns
    out["Date"] = pd.to_datetime(out["date"]).dt.date
    out["Close"] = out["px"].round(2)
    out["VRatio"] = out["v_ratio"].round(2)
    out["Ret5"] = out["ret5"].round(2)
    out["DistToHH"] = out["dist_to_hh"].round(2)
    out["TrendUp"] = out["trend_up"].astype(int)
    out["AvgVol20"] = out["vma20"].round(2)
    out["MktCapA$B"] = (out["mktcap"]/1e9).round(2)
    keep = ["Tier","symbol","Date","Close","Score","VRatio","Ret5","DistToHH","TrendUp","AvgVol20","MktCapA$B","pe","beta","near_earnings_10d"]
    out = out[keep].rename(columns={"symbol":"Ticker","pe":"PE","beta":"Beta"})
    out = out.sort_values("Score", ascending=False)
    return out

def main():
    print(f"Config → years={YEARS} | topN={TOPN} | uni_cap={UNIVERSE_CAP}")
    uni_large = read_universe(U_LARGE)
    uni_mid   = read_universe(U_MID)
    uni_micro = read_universe(U_MICRO)

    large = scan_tier("large", uni_large)
    mid   = scan_tier("mid", uni_mid)
    micro = scan_tier("micro", uni_micro)

    # save topN each tier
    if not large.empty:
        large.head(TOPN).to_csv(os.path.join(OUTDIR,"picks_large.csv"), index=False)
    if not mid.empty:
        mid.head(TOPN).to_csv(os.path.join(OUTDIR,"picks_mid.csv"), index=False)
    if not micro.empty:
        micro.head(TOPN).to_csv(os.path.join(OUTDIR,"picks_micro.csv"), index=False)

    # merge + save combined
    frames = [x for x in [large,mid,micro] if not x.empty]
    if not frames:
        print("No results — check API key or loosen filters.")
        return
    combined = pd.concat(frames, ignore_index=True)
    combined_sorted = combined.sort_values(["Tier","Score"], ascending=[True,False])
    combined_sorted.to_csv(os.path.join(OUTDIR,"picks_combined.csv"), index=False)

    # Pretty print
    def show(df, title):
        if df.empty: return
        print(f"\n=== {title} (Top {TOPN}) ===")
        view = df.head(TOPN)[["Tier","Ticker","Date","Close","Score","VRatio","Ret5","DistToHH","TrendUp","AvgVol20","MktCapA$B","PE","Beta","near_earnings_10d"]]
        print(view.to_string(index=False))

    show(large, "Large Caps")
    show(mid,   "Mid Caps")
    show(micro, "Micro Caps")
    print("\n=== Top Combined (by Score) ===")
    print(combined.sort_values("Score", ascending=False).head(TOPN).to_string(index=False))

if __name__ == "__main__":
    main()